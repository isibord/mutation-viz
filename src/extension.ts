import * as vscode from 'vscode';
import * as MC from './MutateCommand';
import { MutationReportParser } from './parser';
import { activate as activateWelcomePanel } from './WelcomePanel';
import { existsSync, watch, FSWatcher } from 'fs';

/**
 * Path to xml file generated by mutation framework
 */
const reportPath = require('path').join(vscode.workspace.rootPath,
	vscode.workspace.getConfiguration().get('mutation.outputFolder'),
	vscode.workspace.getConfiguration().get('mutation.outputFilename'));

/**
 * This extension's status bar, used to display the current file's killed and alive mutation count.
 */
let myStatusBarItem: vscode.StatusBarItem;

/**
 * Whether the code highlighting decorations are currently visible. Used to toggle between visibility states.
 */
let decorationsVisible = false;

/**
 * A file watcher used to watch the underlying mutation framework output for runtime changes.
 */
let fileWatcher: FSWatcher;

/**
 * A list of the current test output's killed mutations.
 */
const killedMutations: vscode.DecorationOptions[] = [];

/**
 * A list of the current test output's alive mutations.
 */
const aliveMutations: vscode.DecorationOptions[] = [];

/**
 * The decorator type used to decorate alive mutations.
 */
const aliveMutationDecorationType = vscode.window.createTextEditorDecorationType({
	// See package.json for the declaration and default values.
	overviewRulerColor: { id: 'mutation.aliveBackground' },
	overviewRulerLane: vscode.OverviewRulerLane.Left,
	backgroundColor: { id: 'mutation.aliveBackground' }
});

/**
 * The decorator type used to decorate killed mutations
 */
const killedMutationDecorationType = vscode.window.createTextEditorDecorationType({
	// See package.json for the declaration and default values.
	overviewRulerColor: { id: 'mutation.killedBackground' },
	overviewRulerLane: vscode.OverviewRulerLane.Left,
	backgroundColor: { id: 'mutation.killedBackground' }
});

/**
 * This method is called when the extension is activated. The extension is activated the very first time the command is executed
 * @param context VS Code Extension Context
 * @return references to some of the extension's modules
 */
export function activate(context: vscode.ExtensionContext) {
	// Mutate command
	context.subscriptions.push(vscode.commands.registerCommand(MC.CommandName, MC.mutate));

	// Visualize Mutation command
	context.subscriptions.push(vscode.commands.registerCommand('extension.visualize', () => {
		visualizeMutation(context, reportPath);
	}));

	context.subscriptions.push(vscode.commands.registerCommand("ToggleDecorations", () => {
		toggleDecorations();
	}));

	// Create a new status bar item that we can now manage
	myStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);
	myStatusBarItem.command = "ToggleDecorations";
	myStatusBarItem.tooltip = "Toggle code highlighting";
	context.subscriptions.push(myStatusBarItem);

	visualizeMutation(context, reportPath);

	return {
		myStatusBarItem,
		MC
	};
}

/**
 * Attaches decorator for report and triggers welcome panel
 * @param context Current VS Code extension context
 * @param report Mutation Report
 */
function visualizeMutation(context: vscode.ExtensionContext, reportPath: string) {
	if (!existsSync(reportPath)){
		// nothing more to do if the report doesn't exist
		vscode.window.showWarningMessage('No mutation report available to visualize! Right click file and run Mutate');
		return;
	}

	// Generate Mutation Analysis Report, store it in workplace context.
	const report = new MutationReportParser(reportPath);

	// If we've already set up a file watcher, close it in preparation for the new one
	if (fileWatcher)
	{
		fileWatcher.close();
	}

	// Create a file watcher, in case the underlying mutations data is updated
	fileWatcher = watch(reportPath, (_event: string, _filename: string) => {
		report.refreshReport();
		updateDecorations(report);
	});

	// Attach Decorator to Event
	let onchangeActiveText = vscode.window.onDidChangeActiveTextEditor(activeTextEditorListener(report));
	context.subscriptions.push(onchangeActiveText);

	// Initialize the Mutation-Viz Welcome Panel
	const welcomePanel = activateWelcomePanel(context, report.getMutationReport());
}

/**
 * Given a mutation report, update the decoration on a file that has been mutated.
 * @param report MutationReportParser object to get information needed for decoration
 */
function updateDecorations(report : MutationReportParser) {
	if (report === null) {
		// nothing to do
		return;
	}

	let activeEditor = vscode.window.activeTextEditor;

	if (!activeEditor) {
		return;
	}
	
	killedMutations.length = 0;
	aliveMutations.length = 0;

	for (const mutation of report.getMutations()) {
		if (!activeEditor.document.fileName.includes(mutation.sourceFile)) {
			continue;
		}

		let text = activeEditor.document.lineAt(mutation.lineNumber-1);

		if (mutation.isDetected) {
			killedMutations.push({ range: new vscode.Range(mutation.lineNumber-1, text.firstNonWhitespaceCharacterIndex, mutation.lineNumber-1, text.range.end.character), hoverMessage: "KILLED " + mutation.mutatorDescription });
		}
		else {
			aliveMutations.push({ range: new vscode.Range(mutation.lineNumber-1, text.firstNonWhitespaceCharacterIndex, mutation.lineNumber-1, text.range.end.character), hoverMessage: "SURVIVED " + mutation.mutatorDescription });
		}
	}

	let n = killedMutations.length;
	if (killedMutations.length > 0 || aliveMutations.length > 0) {
		myStatusBarItem.text = `Killed: ${killedMutations.length} | Alive: ${aliveMutations.length}`;
		myStatusBarItem.show();
	} else {
		myStatusBarItem.hide();
	}

	addDecorations();
}

/**
 * Used to toggle the code highlighting decorations between visible and hidden.
 */
function toggleDecorations() {
	if (decorationsVisible) {
		removeDecorations();
	}
	else {
		addDecorations();
	}
}

/**
 * Hides the code highlighting decorations.
 */
function removeDecorations() {
	let activeEditor = vscode.window.activeTextEditor;

	if (!activeEditor) {
		return;
	}

	activeEditor.setDecorations(aliveMutationDecorationType, []);
	activeEditor.setDecorations(killedMutationDecorationType, []);

	decorationsVisible = false;
}

/**
 * Makes the code highlighting decorations visible.
 */
function addDecorations() {
	let activeEditor = vscode.window.activeTextEditor;

	if (!activeEditor) {
		return;
	}

	activeEditor.setDecorations(aliveMutationDecorationType, aliveMutations);
	activeEditor.setDecorations(killedMutationDecorationType, killedMutations);

	decorationsVisible = true;
}

/**
 * Triggers update when active text editor changes. Currently updates decorations and summary log
 * @param report MutationReportParser object to get information needed to pass on to decoration and summary display
 */
function activeTextEditorListener(report: MutationReportParser) {
	return () => {
		if (vscode.window.activeTextEditor) {
			if (vscode.window.activeTextEditor.document.uri.scheme === 'file') {
				const enabled = vscode.window.activeTextEditor.document.languageId === 'java';
				if (enabled) {
					// Once a java file is opened, update the decorations and log summary
					updateDecorations(report);
					return;
				}
			}
		}
		myStatusBarItem.hide();
	};
}

/**
 *  This method is called when your extension is deactivated
 */
export function deactivate() {}
